A Simple "Cheat Sheet" for Reading C Declarations
To read these, start at the variable name and work your way out (the "Spiral Rule"):
int (*compar)(...)
Find the name: compar
Look inside parentheses: *compar -> "compar is a pointer..."
Look outside to the right: (...) -> "...to a function..."
Look outside to the left: int -> "...that returns an
int."
int *compar(...)
Find the name: compar
Look to the right: (...) -> "compar is a function..."
Look to the left: int * -> "...that returns a pointer to an int.

Pointers:
---------
int n = 50;    // n has type "int" and its value is an integer, the number 50.
int *p = &n;   // p has type "pointer to int", and its value is an address, the address of the variable n.
printf("%p\n", p); // prints the memory address stored in p.
printf("%i\n", *p); // * dereferences the pointer p; p points to an int, *p is the value of that int.
//  p - pointer (to an int)
// *p - the int that p points to
A good mental model:
p is a map coordinate
*p is whatâ€™s at that coordinate

Arrays decay to pointers:
-------------------------
int arr[5];

// 'arr' decays to 'int*' because that's the type of 'ptr'
int *ptr = arr;

// 'arr' decays to 'int*' to perform pointer arithmetic
int value = *(arr + 2);

When Arrays Don't Decay
1. sizeof Operator: Returns the size of the entire array (e.g., sizeof(arr)), not just the size of a pointer.
2. & Operator Taking the address of an array with &arr gives you a pointer to the whole array, not just the first element. The type of &arr is a pointer to the array type, e.g., int (*)[5] for an int array with 5 elements.
3. Initialization: When an array is declared and initialized, it is fully allocated in memory and does not decay to a pointer.


Project idea:
(Python) : extract stdlib docs from pdf to render in html. Look into pymupdf, pdftotext


C: Unit testing framework.
Assertions from Junit:
assertTrue(boolean, string)
assertFalse(boolean, string)
assertNull(object, string)

for comparison methods, JUnit uses expected, actual. It would be nice to let the user customize this to be
expected, actual or
actual, expected as desired.

assertEquals(T, T, string)
assertNotEquals(T, T, string)
assertSame(ptr, ptr, string)
assertNotSame(ptr, ptr, string)

assertTimeout(duration, function, string)
assertArrayEquals(T[], T[], string)
assertLinesMatch(List<string>, List<string>, string)

assertInstanceOf(Class, Object, string) - probably not useful in C


---------------------------------------------------------------------
C printf format specifiers start on page 228 of the IOC reference.
---------------------------------------------------------------------


* C idea : hash table
* C idea : can we use macros to implement a generic type system for arrays and stacks, like instead of
array_t *array;

we can have
array_t(int) *array:

and generate create/insert/get/append methods for that specific type?


git notess:
-----------
to stop tracking a file in git (in case you accidentally checked something it you didn't mean to:
git rm -r --cached <file_name>
git commit -m "Stop tracking <file_name>"

Exception-like handling
-----------------------
setjmp and longjmp:

    jmp_buf buffer; // defined in setjmp.h

    if ( setjmp(buffer) != 0)) {
      // exception handling
    } else {
      // Try block
      jmp_buf_valid = 1;  // this signals the longjmp code there is a buffer in a good state
      // Here run code that might crash, "throw an exception"
    }

    On the call to setjmp(buffer),it will return 0. Thus the "try" block runs. If the code run from the "try" block
    encounters an "exception", it will do a longjump(buffer, 1). Execution then proceedes from the inital setjmp(buffer)
    call. In this case, the value 1 is returned. Thus the "exception" block now runs.
    To 'throw an exception' in the try-block path, :
        if (jmp_buf_valid)
          longjmp(punit_error_jmp_buf, 1);
